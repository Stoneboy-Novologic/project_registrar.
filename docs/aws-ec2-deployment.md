# AWS EC2 Deployment Guide

Complete guide for deploying the Next.js application to AWS EC2 with Docker, PostgreSQL, and Nginx.

## Architecture Overview

```
┌─────────────────────────────────────────┐
│           AWS EC2 Instance              │
│  ┌────────────────────────────────────┐  │
│  │         Nginx (Port 80/443)        │  │
│  │      Reverse Proxy + SSL           │  │
│  └──────────────┬────────────────────┘  │
│                 │                         │
│  ┌──────────────▼────────────────────┐  │
│  │    Next.js App (Port 3000)         │  │
│  │    Docker Container                │  │
│  └──────────────┬────────────────────┘  │
│                 │                         │
│  ┌──────────────▼────────────────────┐  │
│  │    PostgreSQL (Port 5432)          │  │
│  │    Docker Container                │  │
│  └────────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

## Prerequisites

- AWS Account with EC2 access
- Domain name (optional, for SSL)
- SSH key pair for EC2 access
- Local machine with Docker installed (for testing)

## Step 1: Launch EC2 Instance

1. **Go to AWS EC2 Console**
   - Navigate to EC2 Dashboard
   - Click "Launch Instance"

2. **Configure Instance**
   - **Name**: `editor-app-production`
   - **AMI**: Ubuntu Server 22.04 LTS
   - **Instance Type**: t3.medium (2 vCPU, 4GB RAM) or t3.large (2 vCPU, 8GB RAM)
   - **Key Pair**: Select or create a new key pair
   - **Network Settings**: 
     - Allow SSH (port 22)
     - Allow HTTP (port 80)
     - Allow HTTPS (port 443)

3. **Configure Storage**
   - Root volume: 20GB (gp3)
   - Add additional volume if needed for database backups

4. **Launch Instance**

5. **Allocate Elastic IP**
   - Go to Elastic IPs in EC2 Console
   - Allocate new Elastic IP
   - Associate with your EC2 instance

## Step 2: Initial Server Setup

1. **SSH into EC2 Instance**
   ```bash
   ssh -i your-key.pem ubuntu@<EC2-IP-ADDRESS>
   ```

2. **Run Setup Script**
   ```bash
   # Clone your repository
   git clone <your-repo-url> editor-test
   cd editor-test
   
   # Make scripts executable
   chmod +x scripts/*.sh
   
   # Run setup script
   ./scripts/setup-server.sh
   ```

3. **Log out and log back in** (to apply Docker group changes)
   ```bash
   exit
   ssh -i your-key.pem ubuntu@<EC2-IP-ADDRESS>
   ```

## Step 3: Configure Environment Variables

1. **Create `.env.production` file**
   ```bash
   cd ~/editor-test
   nano .env.production
   ```

2. **Add environment variables**
   ```env
   # Database Configuration
   POSTGRES_USER=admin
   POSTGRES_PASSWORD=your-secure-password-here
   POSTGRES_DB=editor_db
   
   # Database URL (for Prisma)
   DATABASE_URL=postgresql://admin:your-secure-password-here@postgres:5432/editor_db?schema=public
   
   # Application
   NODE_ENV=production
   PORT=3000
   HOSTNAME=0.0.0.0
   
   # PDF Configuration (optional)
   PDF_COMPANY_NAME=BharatERP
   PDF_COMPANY_LOGO_URL=/logo.png
   PDF_WATERMARK_TEXT=CONFIDENTIAL
   PDF_FOOTER_TEXT=Generated by BharatERP Construction Report System
   PDF_COPYRIGHT_TEXT=© 2025 BharatERP. All rights reserved.
   ```

3. **Secure the file**
   ```bash
   chmod 600 .env.production
   ```

## Step 4: Deploy Application

1. **Run deployment script**
   ```bash
   ./scripts/deploy.sh
   ```

   This script will:
   - Build Docker images
   - Run database migrations
   - Start containers
   - Configure Nginx
   - Perform health checks

2. **Verify deployment**
   ```bash
   # Check container status
   docker-compose -f docker-compose.prod.yml ps
   
   # Check application logs
   docker-compose -f docker-compose.prod.yml logs -f app
   
   # Run health check
   ./scripts/health-check.sh
   ```

## Step 5: Configure SSL (Optional but Recommended)

1. **Point your domain to EC2 Elastic IP**
   - Update DNS A record to point to your Elastic IP
   - Wait for DNS propagation (can take up to 48 hours)

2. **Install SSL Certificate**
   ```bash
   ./scripts/install-ssl.sh your-domain.com your-email@example.com
   ```

   This will:
   - Obtain Let's Encrypt certificate
   - Configure Nginx for HTTPS
   - Set up auto-renewal

3. **Verify SSL**
   - Visit `https://your-domain.com`
   - Check certificate validity

## Step 6: Set Up Automated Backups

1. **Create cron job for database backups**
   ```bash
   crontab -e
   ```

2. **Add backup schedule** (daily at 2 AM)
   ```cron
   0 2 * * * cd /home/ubuntu/editor-test && ./scripts/backup-db.sh >> /var/log/db-backup.log 2>&1
   ```

## Step 7: Configure GitHub Actions (Optional)

1. **Add GitHub Secrets**
   - Go to repository Settings → Secrets and variables → Actions
   - Add the following secrets:
     - `EC2_HOST`: Your EC2 Elastic IP or domain
     - `EC2_USER`: `ubuntu` (or your username)
     - `EC2_SSH_KEY`: Your private SSH key content

2. **Push to main branch**
   - The workflow will automatically deploy on push to main/master

## Maintenance

### View Logs
```bash
# Application logs
docker-compose -f docker-compose.prod.yml logs -f app

# Database logs
docker-compose -f docker-compose.prod.yml logs -f postgres

# Nginx logs
sudo tail -f /var/log/nginx/access.log
sudo tail -f /var/log/nginx/error.log
```

### Update Application
```bash
# Zero-downtime update
./scripts/update-app.sh

# Or full redeploy
./scripts/deploy.sh
```

### Database Operations
```bash
# Run migrations
./scripts/migrate-db.sh

# Backup database
./scripts/backup-db.sh

# Restore database
./scripts/restore-db.sh backups/db_backup_YYYYMMDD_HHMMSS.sql.gz
```

### Health Checks
```bash
# Run health check
./scripts/health-check.sh

# Check container status
docker-compose -f docker-compose.prod.yml ps

# Check disk usage
df -h
```

## Troubleshooting

### Application won't start
1. Check logs: `docker-compose -f docker-compose.prod.yml logs app`
2. Verify environment variables: `cat .env.production`
3. Check database connection: `./scripts/health-check.sh`

### Database connection issues
1. Verify PostgreSQL is running: `docker-compose -f docker-compose.prod.yml ps postgres`
2. Check DATABASE_URL in `.env.production`
3. Test connection: `docker-compose -f docker-compose.prod.yml exec postgres psql -U admin -d editor_db`

### Nginx issues
1. Test configuration: `sudo nginx -t`
2. Check error logs: `sudo tail -f /var/log/nginx/error.log`
3. Reload Nginx: `sudo systemctl reload nginx`

### SSL certificate issues
1. Check certificate status: `sudo certbot certificates`
2. Test renewal: `sudo certbot renew --dry-run`
3. Manually renew: `sudo certbot renew`

### Out of memory
1. Check memory usage: `free -h`
2. Consider upgrading to t3.large or larger instance
3. Check container resource limits in docker-compose.prod.yml

## Security Best Practices

1. **Keep system updated**
   ```bash
   sudo apt-get update && sudo apt-get upgrade -y
   ```

2. **Use strong passwords**
   - Generate strong passwords for database
   - Use password manager

3. **Restrict SSH access**
   - Use SSH keys only (disable password authentication)
   - Consider using fail2ban

4. **Regular backups**
   - Automated daily backups
   - Test restore procedures regularly

5. **Monitor logs**
   - Set up log rotation
   - Monitor for suspicious activity

6. **Firewall rules**
   - Only open necessary ports (22, 80, 443)
   - Use security groups effectively

## Cost Optimization

- **Instance sizing**: Start with t3.medium, scale up if needed
- **Storage**: Use gp3 volumes for better price/performance
- **Reserved Instances**: Consider for long-term deployments
- **Monitor usage**: Use AWS Cost Explorer to track spending

## Scaling Considerations

For higher traffic:
1. **Vertical scaling**: Upgrade to larger instance (t3.large, t3.xlarge)
2. **Horizontal scaling**: Use multiple EC2 instances with load balancer
3. **Database**: Consider migrating to RDS for better performance
4. **CDN**: Use CloudFront for static assets

## Support

For issues or questions:
- Check logs first
- Review this documentation
- Check GitHub issues
- Contact support team

